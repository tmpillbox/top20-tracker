#!/usr/bin/env python3

import argparse
from datetime import datetime
import json
import shlex
from typing import Dict, Generator, Iterator, List, Optional, Tuple, Union
import cmd2
from rich.console import Console
from rich.table import Table


CALYEAR = datetime.now().year

class Utility:
    @staticmethod
    def str2bool(arg: str) -> bool:
        arg = arg.lower()
        if arg in [ 'yes', 'y', 'true', 't', '1' ]:
            return True
        elif arg in [ 'no', 'n', 'false', 'f', '0' ]:
            return False
        else:
            raise argparse.ArgumentTypeError("Invalid option, choose from: y, yes, t, true, n, no, f, false, 0, 1")


class CmdResults(cmd2.CommandSet):
    def __init__(self, parent: "TrackerManager"):
        super().__init__()
        self.parent: "TrackerManager" = parent

    def choices_grouped_items(self) -> List[str]:
        return self.parent._choices_grouped_items()
    
    def choices_selected_grouped_items(self) -> List[str]:
        return self.parent._choices_selected_grouped_items()

    select_parser = cmd2.Cmd2ArgumentParser()
    select_parser.add_argument('rank', type=int)

    @cmd2.as_subcommand_to('results', 'select', select_parser)
    def results_select(self, ns: argparse.Namespace):
        self.parent._results_select(ns.rank)

    clear_parser = cmd2.Cmd2ArgumentParser()
    
    @cmd2.as_subcommand_to('results', 'clear', clear_parser)
    def results_clear(self, ns: argparse.Namespace):
        self.parent._results_clear()

    next_parser = cmd2.Cmd2ArgumentParser()

    @cmd2.as_subcommand_to('results', 'next', next_parser)
    def results_next(self, ns: argparse.Namespace):
        self.parent._results_next()

    show_parser = cmd2.Cmd2ArgumentParser()

    @cmd2.as_subcommand_to('results', 'show', show_parser)
    def results_show(self, ns: argparse.Namespace):
        self.parent._results_show()

    list_parser = cmd2.Cmd2ArgumentParser()
    list_parser.add_argument(
        '--max-rank', type=int,
        help='Only show games ranked numerically equal to or lower than --max-rank'
    )
    list_parser.add_argument(
        '--min-rank', type=int,
        help='Only show games ranked numerically equal to or higher than --min-rank'
    )
    list_parser.add_argument(
        '--owned', type=Utility.str2bool,
        help='If specified, only show games either owned or not-owned'
    )
    list_parser.add_argument(
        '--prev-owned', type=Utility.str2bool,
        help='If specified, only show games either previously owned or not marked previously owned'
    )
    list_parser.add_argument(
        '--played', type=Utility.str2bool,
        help='If specified, only show games either played or unplayed'
    )
    list_parser.add_argument(
        '--wishlist', nargs='+',
        choices=[ 'no', 'Low', 'Medium', 'High' ],
        help='If specified, only show games matching one of the provided Wishlist priorities'        
    )
    list_parser.add_argument(
        '--voted', type=Utility.str2bool,
        help='If specified, only show games either voted for or not voted for'
    )

    @cmd2.as_subcommand_to('results', 'list', list_parser)
    def results_list(self, ns: argparse.Namespace):
        self.parent._render_results(ns)

    mark_parser = cmd2.Cmd2ArgumentParser()
    mark_parser_cmd = mark_parser.add_subparsers(dest='command')

    mark_parser_own = mark_parser_cmd.add_parser('own')
    mark_parser_own.add_argument('val', type=bool)

    mark_parser_wishlist = mark_parser_cmd.add_parser('wishlist')
    mark_parser_wishlist.add_argument('val', choices=[ 'no', 'High', 'Medium', 'Low' ])

    mark_parser_played = mark_parser_cmd.add_parser('played')
    mark_parser_played.add_argument('val', type=bool)

    mark_parser_prev_owned = mark_parser_cmd.add_parser('prev_owned')
    mark_parser_prev_owned.add_argument('val', type=bool)

    mark_parser_items = mark_parser_cmd.add_parser('items')
    mark_parser_items_action = mark_parser_items.add_subparsers(dest='action')

    mark_parser_items_add = mark_parser_items_action.add_parser('add')
    mark_parser_items_add.add_argument('item', choices_provider=choices_grouped_items)

    mark_parser_items_del = mark_parser_items_action.add_parser('remove')
    mark_parser_items_del.add_argument('item', choices_provider=choices_selected_grouped_items)



class VoteGame:
    def __init__(self, name: str, data: dict) -> None:
        self.name = name
        self.data = data

    def has_year(self, year: Union[str, int]) -> bool:
        year = str(year)
        if "vote_ranks" in self.data:
            return year in self.data["vote_ranks"]
        return False
    
    def year_rank(self, year: Union[str, int]) -> Optional[str]:
        year = str(year)
        if self.has_year(year):
            return self.data["vote_ranks"][year]
        return None
    
class ResultYear:

    def __init__(self, year: int) -> None:
        self._by_name = dict()
        self._by_gid = dict()
        self._by_rank = dict()

    @property
    def num_results(self) -> int:
        return len(self._by_rank)

    def register_game(self, rank: int, game: "ResultGame") -> None:
        self._by_name[game.name] = game
        self._by_rank[rank] = game

    def by_name(self, name: str) -> Optional["ResultGame"]:
        return self._by_name.get(name)
    
    def by_gid(self, gid: int) -> Optional["ResultGame"]:
        return self._by_gid.get(gid)
    
    def by_rank(self, rank: int) -> Optional["ResultGame"]:
        return self._by_rank.get(rank)
    
    @property
    def as_dict(self) -> Dict:
        obj = dict()
        for rank in sorted(self._by_rank, reverse=True):
            obj[str(rank)] = self.by_rank(rank).as_dict # type: ignore
        return obj
    
    @classmethod
    def from_dict(cls, year: int, year_data: Dict) -> "ResultYear":
        result_year = cls(year)
        for rank, rank_data in year_data.items():
            rank_int = int(rank)
            game = ResultGame.from_dict(rank_data)
            result_year.register_game(rank_int, game)
        return result_year

    
class ResultGame:
    def __init__(self, name: str, own: bool = False, wishlist: str = "no", played: bool = False, prev_owned: bool = False, owned_items: Optional[List] = None) -> None:
        self.name = str(name)
        self.own = bool(own)
        self.wishlist = str(wishlist)
        self.played = bool(played)
        self.prev_owned = bool(prev_owned)
        self.owned_items = list()
        if owned_items is not None and owned_items:
            for item in owned_items:
                if item not in self.owned_items:
                    self.owned_items.append(str(item))
        if self.own and not self.owned_items:
            self.owned_items.append(name)
        
    def update_values(
        self,
        own: Optional[bool] = None,
        wishlist: Optional[str] = None,
        played: Optional[bool] = None,
        prev_owned: Optional[bool] = None,
        add_owned_items: Optional[List[str]] = None,
        del_owned_items: Optional[List[str]] = None
    ) -> None:
        if own is not None:
            self.own = bool(own)
        if wishlist is not None:
            self.wishlist = str(wishlist)
        if played is not None:
            self.played = bool(played)
        if prev_owned is not None:
            self.prev_owned = bool(prev_owned)
        if add_owned_items is not None and add_owned_items:
            for item in add_owned_items:
                if item not in self.owned_items:
                    self.owned_items.append(str(item))
        if del_owned_items is not None and del_owned_items:
            for item in del_owned_items:
                if item in self.owned_items:
                    self.owned_items.remove(item)

    @property 
    def as_dict(self) -> Dict[str,Union[str,bool,List[str]]]:
        obj = {
            "name": self.name,
            "own": self.own,
            "wishlist": self.wishlist,
            "played": self.played,
            "prev_owned": self.prev_owned,
            "owned": [ o for o in self.owned_items ]
        }
        return obj
    
    @classmethod
    def from_dict(cls, game_data: Dict) -> "ResultGame":
        game = cls(
            game_data['name'],
            own=game_data.get('own', False),
            wishlist=game_data.get('wishlist', "no"),
            played=game_data.get('played', False),
            prev_owned=game_data.get('prev_owned', False),
            owned_items=game_data.get('owned', None)
        )
        return game
    
class Results:
    def __init__(self) -> None:
        self.years: Dict[int, ResultYear] = dict()

    @property
    def num_years(self) -> int:
        return len(self.years)
    
    @property
    def num_results(self) -> int:
        return sum([ y.num_results for y in self.years.values() ])
    
    def add_year(self, year: int) -> None:
        if year not in self.years:
            self.years[year]  = ResultYear(year)
        
    def add_result(self, year: int, rank: int, result: ResultGame) -> None:
        if year not in self.years:
            self.add_year(year)
        self.years[year].register_game(rank, result)
    
    def year(self, year: int) -> Optional[ResultYear]:
        return self.years.get(year)
    
    @property
    def as_dict(self) -> Dict:
        obj = dict()
        for year in sorted(self.years.keys()):
            year_data = self.years[year]
            obj[str(year)] = year_data.as_dict
        return obj

    @classmethod 
    def from_dict(cls, data: Dict) -> "Results":
        results: "Results" = cls()
        for year, year_data in data.items():
            int_year = int(year)
            results_year: "ResultYear" = ResultYear.from_dict(int_year, year_data)
            results.years[int_year] = results_year
        return results

class TrackerManager(cmd2.Cmd):
    @staticmethod
    def partial_command(arg_string: str, choices: List[str]) -> str:
        """Returns a full match from a partial string, or raises an error."""
        matches = [ c for c in choices if c.startswith(arg_string) ]

        if not matches:
            raise argparse.ArgumentTypeError(f"Invalid choice: '{arg_string}' (choose from {choices})")
        elif len(matches) > 1:
            raise argparse.ArgumentTypeError(f"Ambiguous choice: '{arg_string}' (matches {matches})")
        else:
            return matches[0]
        
    @staticmethod
    def positive_integer(int_val: str):
        """Returns a valid positive integer or raises an error"""

        if not int_val.isdigit():
            raise argparse.ArgumentTypeError(f"Not an integer: {int_val}")
        elif int(int_val) <= 0:
            raise argparse.ArgumentTypeError(f"Not a positive integer: {int_val}")
        else:
            return int(int_val)

    @staticmethod
    def combobulate_line(args: List[str]):
        return ' '.join([ shlex.quote(arg) for arg in args ])

    def __init__(self, votes_file: str, groupings_file: str, results_file: str, year: int, interactive: bool = False):
        super(TrackerManager, self).__init__(allow_cli_args=False, include_ipy=True, include_py=True)
        self.register_command_set(CmdResults(self))

        self.console = Console()
        self._votes_file = votes_file
        self._groupings_file = groupings_file
        self._results_file = results_file
        self._votes = None
        self._groupings = None
        self._results = Results()
        self.year = year
        self.add_settable(
            cmd2.Settable('year', int, 'Working Year for Results', self, onchange_cb=self._update_year)
        )
        self.interactive = interactive
        self.hier = ''
        self.add_settable(
            cmd2.Settable('hier', str, 'Context level', self, onchange_cb=self._update_hier)
        )
        self.selected_result = None
        self._update_prompt()
        self._load_vote_data()
        self._load_groupings_data()
        self._load_results_data()

    results_parser: cmd2.Cmd2ArgumentParser = cmd2.Cmd2ArgumentParser()
    results_parser_cmd = results_parser.add_subparsers()

    @cmd2.with_argparser(results_parser)
    def do_results(self, ns: argparse.Namespace):
        handler = ns.cmd2_handler.get()
        if handler is not None:
            handler(ns)
        else:
            self.do_help('results')

    def _results_select(self, rank: int) -> None:
        self.hier = f'results {rank}'
        self._update_prompt()
    
    def _results_clear(self) -> None:
        self.hier = ''
        self._update_prompt()

    def _results_next(self) -> None:
        if self.hier.startswith('results '):
            curr_rank = shlex.split(self.hier)[-1]
            next_rank = int(curr_rank) - 1
            self._results_select(next_rank)

    def _update_year(self, _param_name, _old, new) -> None:
        self._update_prompt()

    def _update_hier(self, _param_name, _old, new) -> None:
        self._update_prompt()

    def _load_vote_data(self) -> None:
        try:
            with open(self._votes_file, 'r') as f:
                self._votes = json.load(f)
        except FileNotFoundError:
            self._votes = dict()
            self._save_votes_data()
    
    def _save_votes_data(self) -> None:
        with open(self._votes_file, 'w') as f:
            json.dump(self._votes, f, indent=4)

    def _load_groupings_data(self) -> None:
        try:
            with open(self._groupings_file, 'r') as f:
                self._groupings = json.load(f)
        except FileNotFoundError:
            self._groupings = dict()
            self._save_groupings_data()
    
    def _save_groupings_data(self) -> None:
        with open(self._groupings_file, 'w') as f:
            json.dump(self._groupings, f, indent=4)

    def _load_results_data(self) -> None:
        try:
            with open(self._results_file, 'r') as f:
                results = json.load(f)
                self._results = Results.from_dict(results)
        except FileNotFoundError:
            self._results = Results()
            self._save_results_data()
    
    def _save_results_data(self) -> None:
        with open(self._results_file, 'w') as f:
            json.dump(self._results.as_dict, f, indent=4)

    def _update_prompt(self) -> None:
        if self.hier:
            hier = f'|{self.hier}'
        else:
            hier = ''
        self.prompt = f'{self.year}{hier}> '

    def get_year_data(self, year: Union[str, int]) -> dict:
        year = str(year)
        year_data = dict()
        if self._votes is None or year not in self._votes:
            return dict()
        for name, data in self._votes.items():
            game = VoteGame(name, data)
            vote = game.year_rank(year)
            if vote:
                year_data[vote] = game
        return year_data
    
    def set_vote(self, year: int, vote: str, game: str) -> bool:
        if self._votes is None:
            self._votes = dict()
        if game not in self._votes:
            self.perror(f'"{game}" not found. Please add it first using the "game" command')
            return False
        # Check if there's already a game with the current year and current vote
        year_data = self.get_year_data(year)
        if vote in year_data:
            # Remove vote
            try_del = self.delete_vote(year, vote, game)
            if try_del is False:
                # Delete failed, bail
                return False
        if 'vote_ranks' not in self._votes[game]:
            self._votes[game]["vote_ranks"] = dict()
        self._votes[game]["vote_ranks"][str(year)] = str(vote)
        return True
    
    def confirm(self, message: str, default=False) -> bool:
        while True:
            response = input(f'{message} (y/n): ').lower()

            if response in ['y', 'yes']:
                return True
            elif response in ['n', 'no']:
                return False
            elif response == '':
                # Cancel
                self.perror('Cancelled')
                return default
            else:
                self.perror('Invalid response. Please answer \'y\' or \'n\'.')

    def delete_vote(self, year: int, vote: str, game: str, force: bool = False) -> bool:
        year_data = self.get_year_data(year)
        if vote in year_data:
            if year_data[vote].name != game:
                self.perror(f'Mismatch! This shouldn\'t happen. Please consult your nearest Tyler McGeorge')
                return False
            if force or self.confirm('CONFIRM: delete vote {vote} for game {game}?'):
                if self._votes is not None:
                    del self._votes[game]["vote_ranks"][str(year)]
        return True
    
    def add_game(self, name: str) -> bool:
        if self._votes is None:
            self._votes = dict()
        if name in self._votes:
            # Game exists
            self.pwarning(f'Game "{name}" already exists')
            return False
        self._votes[name] = dict()
        self._votes[name]['vote_ranks'] = dict()
        return True
    
    def delete_game(self, name: str, force: bool = False) -> bool:
        if self._votes is None:
            self._votes = dict()
        if name in self._votes:
            if self._votes[name]["vote_ranks"]:
                # Game has votes registered
                self.perror(f'Cannot delete game "{name}". {len(self._votes[name]["vote_ranks"])} votes recorded for game.')
                return False
            if force or self.confirm('CONFIRM: delete game "{name}"?'):
                del self._votes[name]
                return True
        elif not force:
            self.perror(f'Unable to delete game: does not exist: {name}')
            return False
        return False
    
    @property
    def max_vote(self) -> int:
        year = self.get_year_data(self.year)
        if not year:
            return 0
        return max( year.keys() )
    
    def choices_game_name(self) -> None:
        return self._sorted_game_names()
    
    def choices_groupings_name(self) -> None:
        return self._sorted_groupings_names()
    
    def _sorted_game_names(self) -> List[str]:
        if self._votes is None:
            return list()
        return sorted([ k for k in self._votes.keys() ])
    
    def _choices_grouped_items(self) -> List[str]:
        if self.hier and ' ' in self.hier:
            target = shlex.split(' ')[-1]
            # target could be rank or game name
            if target.isdigit():
                year_data = self._results.year(self.year)
                if year_data is not None:
                    game_name = year_data.by_rank(int(target))
                    if game_name is not None:
                        game_name = game_name.name
                    if game_name is None:
                        group = self._game_in_grouping(target)
                        if self._groupings and group:
                            return self._groupings[group]
                    if game_name is None:
                        return list()
                    group = self._game_in_grouping(game_name)
                    if self._groupings and group:
                        return self._groupings[group]
            else:
                group = self._game_in_grouping(target)
                if self._groupings and group:
                    return self._groupings[group]
        return list()
    
    def _choices_selected_grouped_items(self) -> List[str]:
        if self.hier and ' ' in self.hier:
            target = shlex.split(' ')[-1]
            # target could be rank or game
            if target.isdigit():
                year_data = self._results.year(self.year)
                if year_data is not None:
                    game_name = year_data.by_rank(int(target))
                    if game_name is not None:
                        game_name = game_name.name
                    if game_name is None:
                        group = self._game_in_grouping(target)
                        if self._groupings and group:
                            return self._groupings[group]
                    return list()
            else:
                group = self._game_in_grouping(target)
                if self._groupings and group:
                    return self._groupings[group]
        return list()
    
    def _resolve_results_hier(self) -> Optional[int]:
        if self.hier.startswith('results '):
            rank = self.hier[len('results '):]
            if rank.isdigit():
                return int(rank)
        return None
    
    def _results_show(self) -> None:
        rank = self._resolve_results_hier()
        if rank is None:
            return
        year = self._results.year(self.year)
        if year is None:
            return
        result = year.by_rank(rank)
        if result is None:
            self.poutput('Not Found')
            return
        table = Table(title=result.name)
        table.show_header = False
        table.add_column('')
        table.add_column('')
        
        table.add_row('OWN', 'Yes' if result.own else 'No')
        table.add_row('PREV_OWNED', 'Yes' if result.prev_owned else 'No')
        table.add_row('WISHLIST', result.wishlist)
        table.add_row('PLAYED', 'Yes' if result.played else 'No')
        table.add_row('OWNED ITEMS', '\n'.join(result.owned_items))

        self.console.print(table)
        

    def _sorted_groupings_names(self) -> List[str]:
        if self._groupings is not None:
            return sorted([ k for k in self._groupings.keys() ])
        return list()
    
    def _game_in_grouping(self, name: str) -> Union[None, str]:
        if name in self._groupings: # type: ignore
            return name
        if self._groupings is None:
            return None
        for group, entries in self._groupings.items():
            if name in entries:
                return group
        return None

    def _game_by_vote(self, rank: Union[int, str]) -> Optional[VoteGame]:
        year = self.get_year_data(self.year)
        rank = str(rank)
        if rank in year:
            return year[rank]
        return None
   
    def _render_votes_table(self) -> None:
        table = Table(title='Votes')

        table.add_column('VOTE')
        table.add_column('GAME')

        year_data = self.get_year_data(self.year)
        max_vote = 0
        for vote_rank in year_data:
            if vote_rank.isdigit():
                max_vote = max(max_vote, int(vote_rank))

        votes_seen = set()
        
        for vote_rank in range(max_vote):
            votes_seen.add(str(vote_rank + 1))
            game = self._game_by_vote(vote_rank + 1)
            if game is None:
                name = ''
            else:
                name = game.name
            table.add_row(str(vote_rank + 1), name)

        for vote_rank, game in year_data.items():
            if vote_rank in votes_seen:
                continue
            table.add_row(vote_rank, game.name)
        self.console.print(table)

    def _render_games_table(self) -> None:
        if self._votes is None:
            return
        table = Table(title='Games')
        table.add_column('Game')
        game_names = sorted([
            name for name in self._votes
        ])

        for name in game_names:
            table.add_row(name)

        self.console.print(table)

    def _render_one_game(self, game_name: str) -> None:
        table = Table(title=game_name)
        grouping = self._game_in_grouping(game_name)
        if grouping is not None:
            table.caption = f'In Grouping: {grouping}'
        table.add_column('YEAR')
        table.add_column('VOTE')
        if self._votes:
            for year, vote in self._votes[game_name]["vote_ranks"].items():
                table.add_row(year, vote)
        
        self.console.print(table)

    def vote_by_name(self, name: str) -> str:
        if self._votes is None:
            return "N/A"
        if name in self._votes and str(self.year) in self._votes[name]['vote_ranks']:
            return self._votes[name]['vote_ranks'][str(self.year)]
        return "N/A"

    def get_result_year_items(self, year: int) -> Iterator[Tuple[int, ResultGame]]:
        result_year = self._results.year(year)
        if result_year is None or not result_year._by_rank:
            return
        ranks = sorted(result_year._by_rank, reverse=True)
        for rank in ranks:
            item = result_year.by_rank(rank)
            if item is not None:
                yield (rank, item)
    
    def _render_results(self, ns: argparse.Namespace) -> None:
        table = Table(title="Results")

        table.add_column('RANK')
        table.add_column('GAME')
        table.add_column('OWN')
        table.add_column('SOLD')
        table.add_column('WANT')
        table.add_column('PLAYED')
        table.add_column('VOTED')

        result_rows: int = 0

        rank: int
        result: ResultGame
        for rank, result  in self.get_result_year_items(self.year):
            match result.wishlist:
                case 'no':
                    wish = '×'
                case 'High':
                    wish = '▀'
                case 'Medium':
                    wish = '•'
                case 'Low':
                    wish = '▄'
                case _:
                    wish = '?'
            
            vote = self.vote_by_name(result.name)

            if ns.max_rank is not None:
                if ns.max_rank < rank:
                    continue
            if ns.min_rank is not None:
                if ns.min_rank > rank:
                    continue
            if ns.owned is not None:
                if ns.owned != result.own:
                    continue
            if ns.prev_owned is not None:
                if ns.prev_owned != result.prev_owned:
                    continue
            if ns.played is not None:
                if ns.played != result.played:
                    continue
            if ns.wishlist is not None:
                if result.wishlist not in ns.wishlist:
                    continue
            if ns.voted is not None:
                if ns.voted and vote == 'N/A':
                    continue
                if not ns.voted and vote != 'N/A':
                    continue

            table.add_row(
                str(rank),
                result.name,
                'Y' if result.own else 'N',
                'Y' if result.prev_owned else 'N',
                wish,
                'Y' if result.played else 'N',
                vote
            )
            result_rows += 1

        self.console.print(table)
        self.poutput(f'{result_rows} results')

    delete_parser: cmd2.Cmd2ArgumentParser = cmd2.Cmd2ArgumentParser()
    delete_parser.add_argument(
        '--force', action='store_true', default=False
    )
    delete_parser_typ = delete_parser.add_subparsers(dest='command', title='commands')
    delete_typ_vote: cmd2.Cmd2ArgumentParser = delete_parser_typ.add_parser('vote')
    delete_typ_vote.add_argument(
        'vote', type=str
    )

    delete_typ_game: cmd2.Cmd2ArgumentParser = delete_parser_typ.add_parser('game')
    delete_typ_game.add_argument(
        'game', type=str,
        choices_provider=choices_game_name
    )

    @cmd2.with_argparser(delete_parser)
    def do_delete(self, args: argparse.Namespace) -> None:
        if not args.command or args.command not in [ 'vote', 'game' ]:
            self.perror('invalid delete command: "delete vote" or "delete game" is required')
            return
        match args.command:
            case 'vote':
                year = int(self.year)
                vote = str(args.vote)
                year_data = self.get_year_data(year)
                if vote in year_data:
                    self.delete_vote(year, vote, year_data[vote].name, force=args.force)
            case 'game':
                if args.game in self._votes:
                    self.delete_game(args.game, force=args.force)

    show_parser = cmd2.Cmd2ArgumentParser()
    show_parser_typ = show_parser.add_subparsers(dest='command', title='commands')
    show_typ_votes = show_parser_typ.add_parser('votes')

    show_typ_games: cmd2.Cmd2ArgumentParser = show_parser_typ.add_parser('games')
    show_typ_games.add_argument(
        'name', nargs='*', type=str,
        choices_provider=choices_game_name
    )

    @cmd2.with_argparser(show_parser)
    def do_show(self, args: argparse.Namespace) -> None:
        command = args.command
        if command is None:
            # Default to show votes
            self._render_votes_table()
            return
        match command:
            case 'games':
                game_names = self._sorted_game_names()
                if args.name:
                    for name in args.name:
                        if name in game_names:
                            self._render_one_game(name)
                        else:
                            self.perror(f'No data found: {name}')
                    return
                self._render_games_table()
            case 'votes':
                self._render_votes_table()
            case _:
                print (f"not found: {command}")

    game_parser: cmd2.Cmd2ArgumentParser = cmd2.Cmd2ArgumentParser()
    game_parser.add_argument('--force', action='store_true', default=False)
    game_parser.add_argument(
        'command', choices=[ 'list', 'show', 'add', 'delete' ] 
    )
    game_parser.add_argument(
        'name', choices_provider=choices_game_name, default='', nargs='?' 
    )

    @cmd2.with_argparser(game_parser)
    def do_game(self, args: argparse.Namespace) -> None:
        if not args.command or args.command not in [ 'list', 'show', 'add', 'delete' ]:
            self.perror('Invalid command: must choose \'game show\', \'game add\', or \'game delete\'.')
            return

        match args.command: 
            case 'list':
                return self._render_games_table()
            case 'show':
                    if args.name is None or len(args.name) == 0:
                        self.perror('game show: must provide game name(s)')
                    match = self.partial_command(args.name, self._sorted_game_names())
                    self._render_one_game(match)
                    return
            case 'add':
                self.add_game(args.name)
                return
            case 'delete':
                if args.name is None or len(args.name) == 0:
                    self.perror('game delete: must specify game name(s)')
                    return
                self.delete_game(args.name, force=args.force)
                return
        
        self.perror('Invalid \'game\' command. You should not see this.')


    vote_parser: argparse.ArgumentParser = cmd2.Cmd2ArgumentParser()
    vote_parser.add_argument(
        'vote', type=str
    )
    vote_parser.add_argument(
        'game', choices_provider=choices_game_name
    )

    @cmd2.with_argparser(vote_parser)
    def do_vote(self, args: argparse.Namespace) -> None:
        self.set_vote(self.year, args.vote, args.game)

    groupings_parser: cmd2.Cmd2ArgumentParser = cmd2.Cmd2ArgumentParser()
    groupings_parser_cmd: argparse._SubParsersAction = groupings_parser.add_subparsers(dest='command', title='subcommands')

    groupings_parser_list: cmd2.Cmd2ArgumentParser = groupings_parser_cmd.add_parser('list')

    groupings_parser_show: cmd2.Cmd2ArgumentParser = groupings_parser_cmd.add_parser('show')
    groupings_parser_show.add_argument(
        'name', choices_provider=choices_groupings_name
    )

    groupings_parser_clear: cmd2.Cmd2ArgumentParser = groupings_parser_cmd.add_parser('clear')

    groupings_parser_import: cmd2.Cmd2ArgumentParser = groupings_parser_cmd.add_parser('import')
    groupings_parser_import.add_argument(
        'import_file', completer=cmd2.Cmd.path_complete,
        help='Path to raw groupings file'
    )

    @cmd2.with_argparser(groupings_parser)
    def do_groupings(self, args: argparse.Namespace) -> None:
        if args.command is None:
            self.perror('groupings: must choose subcommand: list, show, import, clear')
            return
        match args.command:
            case 'list':
                self._render_groupings_table()
            case 'show':
                self._render_one_grouping(args.name)
            case 'import':
                self._import_groupings(args.import_file)
            case 'clear':
                self._clear_groupings()
            case _:
                self.perror('groupings: must choose subcommand: list, show, import, clear')
        return

    def _render_groupings_table(self) -> None:
        if self._groupings is None:
            return
        table = Table(title='Groupings')
        table.add_column('# Entries')
        table.add_column('Grouping')
        groupings = sorted([
            name for name in self._groupings
        ])

        for name in groupings:
            table.add_row(str(len(self._groupings[name])), name)

        self.console.print(table)

    def _render_one_grouping(self, name: str) -> None:
        if self._groupings is None:
            return
        if name not in self._groupings:
            self.pwarning(f'warning: could not find grouping: {name}')
            return
        table = Table(title='GROUPING DATA')
        table.add_column(name)

        for entry in self._groupings[name]:
            if entry != name:
                table.add_row(entry)
        
        self.console.print(table)
    
    def _clear_groupings(self) -> bool:
        if self.confirm('CONFIRM: clear groupings data?'):
            self._groupings = dict()
            return True
        return False

    def _import_groupings(self, groupings_raw: str) -> None:
        try:
            with open(groupings_raw, 'r') as f:
                raw_groupings = json.load(f)
        except:
            import pdb; pdb.set_trace()
            return
        if not isinstance(raw_groupings, list):
            self.perror('error: groupings import: invalid data')
            return
        for group in raw_groupings:
            lead_game = group['leadGame']['name']
            if lead_game in self._groupings:
                self.pwarning(f'EXISTING GROUP: replacing {lead_game}')
                del self._groupings[lead_game] # type: ignore
            names = [ game['name'] for game in group['games'] ]
            for name in names:
                existing = self._game_in_grouping(name)
                if existing is not None:
                    self.pwarning(f'warning: game {name} found in existing grouping: {existing}')
            self._groupings[lead_game] = list(set(names)) # type: ignore

    results_parser: cmd2.Cmd2ArgumentParser = cmd2.Cmd2ArgumentParser()
    results_parser_cmd = results_parser.add_subparsers(dest='command', title='subcommands')

    #results_parser_show = 

    rollback_parser: cmd2.Cmd2ArgumentParser = cmd2.Cmd2ArgumentParser()
    rollback_parser.add_argument('data', choices=[ 'all', 'votes', 'results', 'groupings' ])

    save_parser: cmd2.Cmd2ArgumentParser = cmd2.Cmd2ArgumentParser()
    save_parser.add_argument('data', choices=[ 'all', 'votes', 'results', 'groupings'] )

    @cmd2.with_argparser(rollback_parser)
    def do_rollback(self, args) -> None:
        if args.data in [ 'all', 'votes' ]:
            self._load_vote_data()
            self.pfeedback(f'LOADED {len(self._votes)} voting record games') # type: ignore
        if args.data in [ 'all', 'results' ]:
            self._load_results_data()
            self.pfeedback(f'LOADED {sum([ len(v) for v in self._results.values() ])} results from {len(self._results)} years') # type: ignore
        if args.data in [ 'all', 'groupings' ]:
            self._load_groupings_data()
            self.pfeedback(f'LOADED {sum([ len(v) for v in self._groupings.values() ])} entries in {len(self._groupings)} groups') # type: ignore
    
    @cmd2.with_argparser(save_parser)
    def do_save(self, args) -> None:
        if args.data in [ 'all', 'votes' ]:
            self._save_votes_data()
            self.pfeedback(f'SAVED {len(self._votes)} games') # type: ignore
        if args.data in [ 'all', 'results' ]:
            self._save_results_data()
            self.pfeedback(f'SAVED {self._results.num_results} results from {self._results.num_years} years')
        if args.data in [ 'all', 'groupings' ]:
            self._save_groupings_data()
            self.pfeedback(f'SAVED {sum([ len(v) for v in self._groupings.values() ])} entries in {len(self._groupings)} groups') # type: ignore

    year_parser = cmd2.Cmd2ArgumentParser()
    year_parser.add_argument('year', type=int)

    @cmd2.with_argparser(year_parser)
    def do_year(self, args: argparse.Namespace) -> None:
        if args.year is not None:
            self.year = args.year
            self.poutput(f'Changed year to {self.year}')
            self._update_prompt()
        else:
            self.perror(f'Invalid year: {args.year}')
    

def main(params: argparse.Namespace, args: List[str]) -> None:
    year = params.year
    if not year:
        year = CALYEAR
    interactive = None
    if params.interactive:
        interactive = True
    if params.no_interactive:
        interactive = False
    if interactive is None:
        interactive = not args
    
    votes_manager = TrackerManager(
        votes_file=params.votes_file,
        groupings_file=params.groupings_file,
        results_file=params.results_file,
        year=year,
        interactive=interactive
    )
    if interactive:
        votes_manager.cmdloop(TrackerManager.combobulate_line(args))
    else:
        votes_manager.onecmd(TrackerManager.combobulate_line(args))


if __name__ == '__main__':
    parser = cmd2.Cmd2ArgumentParser("votes", description="manage votes")
    parser.add_argument(
        '--year', '-Y',
        default='',
        help=f'Specify a year. Defaults to the current calendar year. CURRENTLY: {CALYEAR}'
    )
    parser.add_argument(
        '--votes-file', '-V',
        default='votes.json',
        help='file to load and save voting data'
    )
    parser.add_argument(
        '--groupings-file', '-G',
        default='groupings.json',
        help='file to lad and save groupings'
    )
    parser.add_argument(
        '--results-file', '-R',
        default='results.json',
        help='file to load and save results'
    )
    parser.add_argument(
        '--interactive', '-i',
        action='store_true',
        help='Force interactive mode'
    )
    parser.add_argument(
        '--no-interactive', '-I',
        action='store_true',
        help='Force disable interactive mode'
    )

    params = parser.parse_known_args()
    args = list()
    if isinstance(params, tuple):
        params, args = params
    main(params, args)
