#!/usr/bin/env python3

import argparse
from datetime import datetime
import json
import shlex
from typing import List, Optional, Union
import cmd2
from rich.console import Console
from rich.table import Table


CALYEAR = datetime.now().year

class VoteGame:
    def __init__(self, name: str, data: dict) -> None:
        self.name = name
        self.data = data

    def has_year(self, year: Union[str, int]) -> bool:
        year = str(year)
        if "vote_ranks" in self.data:
            return year in self.data["vote_ranks"]
        return False
    
    def year_rank(self, year: Union[str, int]) -> Optional[str]:
        year = str(year)
        if self.has_year(year):
            return self.data["vote_ranks"][year]
        return None

class TrackerManager(cmd2.Cmd):
    @staticmethod
    def partial_command(arg_string: str, choices: List[str]) -> str:
        """Returns a full match from a partial string, or raises an error."""
        matches = [ c for c in choices if c.startswith(arg_string) ]

        if not matches:
            raise argparse.ArgumentTypeError(f"Invalid choice: '{arg_string}' (choose from {choices})")
        elif len(matches) > 1:
            raise argparse.ArgumentTypeError(f"Ambiguous choice: '{arg_string}' (matches {matches})")
        else:
            return matches[0]
        
    @staticmethod
    def positive_integer(int_val: str):
        """Returns a valid positive integer or raises an error"""

        if not int_val.isdigit():
            raise argparse.ArgumentTypeError(f"Not an integer: {int_val}")
        elif int(int_val) <= 0:
            raise argparse.ArgumentTypeError(f"Not a positive integer: {int_val}")
        else:
            return int(int_val)

    @staticmethod
    def combobulate_line(args: List[str]):
        return ' '.join([ shlex.quote(arg) for arg in args ])

    def __init__(self, votes_file: str, groupings_file: str, results_file: str, year: int, interactive: bool = False):
        super(TrackerManager, self).__init__(allow_cli_args=False)
        self.console = Console()
        self._votes_file = votes_file
        self._groupings_file = groupings_file
        self._results_file = results_file
        self._votes = None
        self._groupings = None
        self._results = None
        self.year = year
        self.interactive = interactive
        self.hier = ''
        self._update_prompt()
        self._load_vote_data()
        self._load_groupings_data()
        self._load_results_data()

    def _load_vote_data(self) -> None:
        try:
            with open(self._votes_file, 'r') as f:
                self._votes = json.load(f)
        except FileNotFoundError:
            self._votes = dict()
            self._save_votes_data()
    
    def _save_votes_data(self) -> None:
        with open(self._votes_file, 'w') as f:
            json.dump(self._votes, f, indent=4)

    def _load_groupings_data(self) -> None:
        try:
            with open(self._groupings_file, 'r') as f:
                self._groupings = json.load(f)
        except FileNotFoundError:
            self._groupings = dict()
            self._save_groupings_data()
    
    def _save_groupings_data(self) -> None:
        with open(self._groupings_file, 'w') as f:
            json.dump(self._groupings, f, indent=4)

    def _load_results_data(self) -> None:
        try:
            with open(self._results_file, 'r') as f:
                self._results = json.load(f)
        except FileNotFoundError:
            self._results = dict()
            self._save_results_data()
    
    def _save_results_data(self) -> None:
        with open(self._results_file, 'w') as f:
            json.dump(self._results, f, indent=4)

    def _update_prompt(self) -> None:
        self.prompt = f'{self.year}{self.hier}> '

    def get_year_data(self, year: Union[str, int]) -> dict:
        year = str(year)
        year_data = dict()
        for name, data in self._votes.items():
            game = VoteGame(name, data)
            vote = game.year_rank(year)
            if vote:
                year_data[vote] = game
        return year_data
    
    def set_vote(self, year: int, vote: str, game: str) -> bool:
        if game not in self._votes:
            self.poutput(f'"{game}" not found. Please add it first using the "game" command')
            return False
        # Check if there's already a game with the current year and current vote
        year_data = self.get_year_data(year)
        if vote in year_data:
            # Remove vote
            try_del = self.delete_vote(year, vote, game)
            if try_del is False:
                # Delete failed, bail
                return False
        if 'vote_ranks' not in self._votes[game]:
            self._votes[game]["vote_ranks"] = dict()
        self._votes[game]["vote_ranks"][str(year)] = str(vote)
        return True
    
    def confirm(self, message: str, default=False) -> bool:
        while True:
            response = input(f'{message} (y/n): ').lower()

            if response in ['y', 'yes']:
                return True
            elif response in ['n', 'no']:
                return False
            elif response == '':
                # Cancel
                self.poutput('Cancelled')
                return default
            else:
                self.poutput('Invalid response. Please answer \'y\' or \'n\'.')

    def delete_vote(self, year: int, vote: int, game: str, force: bool = False) -> bool:
        year_data = self.get_year_data(year)
        if vote in year_data:
            if year_data[vote].name != game:
                self.poutput(f'Mismatch! This shouldn\'t happen. Please consult your nearest Tyler McGeorge')
                return False
            if force or self.confirm('CONFIRM: delete vote {vote} for game {game}?'):
                del self._votes[game]["vote_ranks"][str(year)]
        return True
    
    def add_game(self, name: str) -> bool:
        if name in self._votes:
            # Game exists
            self.poutput(f'Game "{name}" already exists')
            return False
        self._votes[name] = dict()
        self._votes[name]['vote_ranks'] = dict()
    
    def delete_game(self, name: str, force: bool = False) -> bool:
        if name in self._votes:
            if self._votes[name]["vote_ranks"]:
                # Game has votes registered
                self.poutput(f'Cannot delete game "{name}". {len(self._votes[name]["vote_ranks"])} votes recorded for game.')
                return False
            if force or self.confirm('CONFIRM: delete game "{name}"?'):
                del self._votes[name]
                return True
        elif not force:
            self.poutput(f'Unable to delete game: does not exist: {name}')
    
    @property
    def max_vote(self) -> int:
        year = self.get_year_data(self.year)
        if not year:
            return 0
        return max( year.keys() )
    
    def choices_game_name(self):
        return self._sorted_game_names()
    
    def choices_groupings_name(self):
        return self._sorted_groupings_names()
    
    def _sorted_game_names(self):
        return sorted([ k for k in self._votes.keys() ])
    
    def _sorted_groupings_names(self):
        return sorted([ k for k in self._groupings.keys() ])
    
    def _game_in_grouping(self, name: str) -> Union[None, str]:
        if name in self._groupings:
            return name
        for group, entries in self._groupings.items():
            if name in entries:
                return group
        return None

    def _game_by_vote(self, rank: Union[int, str]) -> VoteGame:
        year = self.get_year_data(self.year)
        rank = str(rank)
        if rank in year:
            return year[rank]
        return None
   
    def _render_votes_table(self) -> None:
        table = Table(title='Votes')

        table.add_column('VOTE')
        table.add_column('GAME')

        year_data = self.get_year_data(self.year)
        max_vote = 0
        for vote_rank in year_data:
            if vote_rank.isdigit():
                max_vote = max(max_vote, int(vote_rank))

        votes_seen = set()
        
        for vote_rank in range(max_vote):
            votes_seen.add(str(vote_rank + 1))
            game = self._game_by_vote(vote_rank + 1)
            if game is None:
                name = ''
            else:
                name = game.name
            table.add_row(str(vote_rank + 1), name)

        for vote_rank, game in year_data.items():
            if vote_rank in votes_seen:
                continue
            table.add_row(vote_rank, game.name)
        self.console.print(table)

    def _render_games_table(self) -> None:
        table = Table(title='Games')
        table.add_column('Game')
        game_names = sorted([
            name for name in self._votes
        ])

        for name in game_names:
            table.add_row(name)

        self.console.print(table)

    def _render_one_game(self, game_name: str) -> None:
        table = Table(title=game_name)
        grouping = self._game_in_grouping(game_name)
        if grouping is not None:
            table.caption = f'In Grouping: {grouping}'
        table.add_column('YEAR')
        table.add_column('VOTE')
        for year, vote in self._votes[game_name]["vote_ranks"].items():
            table.add_row(year, vote)
        
        self.console.print(table)

    delete_parser: cmd2.Cmd2ArgumentParser = cmd2.Cmd2ArgumentParser()
    delete_parser.add_argument(
        '--force', action='store_true', default=False
    )
    delete_parser_typ = delete_parser.add_subparsers(dest='command', title='commands')
    delete_typ_vote: cmd2.Cmd2ArgumentParser = delete_parser_typ.add_parser('vote')
    delete_typ_vote.add_argument(
        'vote', type=lambda i: TrackerManager.positive_integer(i)
    )

    delete_typ_game: cmd2.Cmd2ArgumentParser = delete_parser_typ.add_parser('game')
    delete_typ_game.add_argument(
        'game', type=str,
        choices_provider=choices_game_name
    )

    @cmd2.with_argparser(delete_parser)
    def do_delete(self, args: argparse.Namespace) -> None:
        if not args.command or args.command not in [ 'vote', 'game' ]:
            self.poutput('invalid delete command: "delete vote" or "delete game" is required')
            return
        match args.command:
            case 'vote':
                year = int(self.year)
                vote = int(args.vote)
                year_data = self.get_year_data(year)
                if vote in year_data:
                    self.delete_vote(year, vote, year_data[vote].name, force=args.force)
            case 'game':
                if args.game in self._votes:
                    self.delete_game(args.game, force=args.force)

    show_parser = cmd2.Cmd2ArgumentParser()
    show_parser_typ = show_parser.add_subparsers(dest='command', title='commands')
    show_typ_votes = show_parser_typ.add_parser('votes')

    show_typ_games: cmd2.Cmd2ArgumentParser = show_parser_typ.add_parser('games')
    show_typ_games.add_argument(
        'name', nargs='*', type=str,
        choices_provider=choices_game_name
    )

    @cmd2.with_argparser(show_parser)
    def do_show(self, args: argparse.Namespace) -> None:
        command = args.command
        if command is None:
            # Default to show votes
            self._render_votes_table()
            return
        match command:
            case 'games':
                game_names = self._sorted_game_names()
                if args.name:
                    for name in args.name:
                        if name in game_names:
                            self._render_one_game(name)
                        else:
                            self.poutput(f'No data found: {name}')
                    return
                self._render_games_table()
            case 'votes':
                self._render_votes_table()
            case _:
                print (f"not found: {command}")

    game_parser: cmd2.Cmd2ArgumentParser = cmd2.Cmd2ArgumentParser()
    game_parser.add_argument('--force', action='store_true', default=False)
    game_parser.add_argument(
        'command', choices=[ 'list', 'show', 'add', 'delete' ] 
    )
    game_parser.add_argument(
        'name', choices_provider=choices_game_name, default='', nargs='?' 
    )

    @cmd2.with_argparser(game_parser)
    def do_game(self, args: argparse.Namespace) -> None:
        if not args.command or args.command not in [ 'list', 'show', 'add', 'delete' ]:
            self.poutput('Invalid command: must choose \'game show\', \'game add\', or \'game delete\'.')
            return

        match args.command: 
            case 'list':
                return self._render_games_table()
            case 'show':
                    if args.name is None or len(args.name) == 0:
                        self.poutput('game show: must provide game name(s)')
                    match = self.partial_command(args.name, self._sorted_game_names())
                    self._render_one_game(match)
                    return
            case 'add':
                return self.add_game(args.name)
            case 'delete':
                if args.name is None or len(args.name) == 0:
                    self.poutput('game delete: must specify game name(s)')
                    return
                self.delete_game(args.name, force=args.force)
                return
        
        self.poutput('Invalid \'game\' command. You should not see this.')


    vote_parser: argparse.ArgumentParser = cmd2.Cmd2ArgumentParser()
    vote_parser.add_argument(
        'vote', type=str
    )
    vote_parser.add_argument(
        'game', choices_provider=choices_game_name
    )

    @cmd2.with_argparser(vote_parser)
    def do_vote(self, args: argparse.Namespace) -> None:
        self.set_vote(self.year, args.vote, args.game)

    groupings_parser: cmd2.Cmd2ArgumentParser = cmd2.Cmd2ArgumentParser()
    groupings_parser_cmd: argparse._SubParsersAction = groupings_parser.add_subparsers(dest='command', title='subcommands')

    groupings_parser_list: cmd2.Cmd2ArgumentParser = groupings_parser_cmd.add_parser('list')

    groupings_parser_show: cmd2.Cmd2ArgumentParser = groupings_parser_cmd.add_parser('show')
    groupings_parser_show.add_argument(
        'name', choices_provider=choices_groupings_name
    )

    groupings_parser_clear: cmd2.Cmd2ArgumentParser = groupings_parser_cmd.add_parser('clear')

    groupings_parser_import: cmd2.Cmd2ArgumentParser = groupings_parser_cmd.add_parser('import')
    groupings_parser_import.add_argument(
        'import_file', completer=cmd2.Cmd.path_complete,
        help='Path to raw groupings file'
    )

    @cmd2.with_argparser(groupings_parser)
    def do_groupings(self, args: argparse.Namespace) -> None:
        if args.command is None:
            self.poutput('groupings: must choose subcommand: list, show, import, clear')
            return
        match args.command:
            case 'list':
                self._render_groupings_table()
            case 'show':
                self._render_one_grouping(args.name)
            case 'import':
                self._import_groupings(args.import_file)
            case 'clear':
                self._clear_groupings()
            case _:
                self.poutput('groupings: must choose subcommand: list, show, import, clear')
        return

    def _render_groupings_table(self) -> None:
        table = Table(title='Groupings')
        table.add_column('# Entries')
        table.add_column('Grouping')
        groupings = sorted([
            name for name in self._groupings
        ])

        for name in groupings:
            table.add_row(str(len(self._groupings[name])), name)

        self.console.print(table)

    def _render_one_grouping(self, name: str) -> None:
        if name not in self._groupings:
            self.poutput(f'warning: could not find grouping: {name}')
            return
        table = Table(title='GROUPING DATA')
        table.add_column(name)

        for entry in self._groupings[name]:
            if entry != name:
                table.add_row(entry)
        
        self.console.print(table)
    
    def _clear_groupings(self) -> bool:
        if self.confirm('CONFIRM: clear groupings data?'):
            self._groupings = dict()

    def _import_groupings(self, groupings_raw: str) -> None:
        try:
            with open(groupings_raw, 'r') as f:
                raw_groupings = json.load(f)
        except:
            import pdb; pdb.set_trace()
            return
        if not isinstance(raw_groupings, list):
            self.poutput('error: groupings import: invalid data')
            return
        for group in raw_groupings:
            lead_game = group['leadGame']['name']
            if lead_game in self._groupings:
                self.poutput(f'EXISTING GROUP: replacing {lead_game}')
                del self._groupings[lead_game]
            names = [ game['name'] for game in group['games'] ]
            for name in names:
                existing = self._game_in_grouping(name)
                if existing is not None:
                    self.poutput(f'warning: game {name} found in existing grouping: {existing}')
            self._groupings[lead_game] = list(set(names))

    rollback_parser: cmd2.Cmd2ArgumentParser = cmd2.Cmd2ArgumentParser()
    rollback_parser.add_argument('data', choices=[ 'all', 'votes', 'results', 'groupings' ])

    save_parser: cmd2.Cmd2ArgumentParser = cmd2.Cmd2ArgumentParser()
    save_parser.add_argument('data', choices=[ 'all', 'votes', 'results', 'groupings'] )

    @cmd2.with_argparser(rollback_parser)
    def do_rollback(self, args):
        if args.data in [ 'all', 'votes' ]:
            self._load_vote_data()
            self.poutput(f'LOADED {len(self._votes)} voting record games')
        if args.data in [ 'all', 'results' ]:
            self._load_results_data()
            self.poutput(f'LOADED {sum([ len(v) for v in self._results.values() ])} results from {len(self._results)} years')
        if args.data in [ 'all', 'groupings' ]:
            self._load_groupings_data()
            self.poutput(f'LOADED {sum([ len(v) for v in self._groupings.values() ])} entries in {len(self._groupings)} groups')
    
    @cmd2.with_argparser(save_parser)
    def do_save(self, args):
        if args.data in [ 'all', 'votes' ]:
            self._save_votes_data()
            self.poutput(f'SAVED {len(self._votes)} games')
        if args.data in [ 'all', 'results' ]:
            self._save_results_data()
            self.poutput(f'SAVED {sum([ len(v) for v in self._results.values() ])} results from {len(self._results)} years')
        if args.data in [ 'all', 'groupings' ]:
            self._save_groupings_data()
            self.poutput(f'SAVED {sum([ len(v) for v in self._groupings.values() ])} entries in {len(self._groupings)} groups')

    year_parser = cmd2.Cmd2ArgumentParser()
    year_parser.add_argument('year', type=int)

    @cmd2.with_argparser(year_parser)
    def do_year(self, args: argparse.Namespace) -> None:
        if args.year is not None:
            self.year = args.year
            self.poutput(f'Changed year to {self.year}')
            self._update_prompt()
        else:
            self.poutput(f'Invalid year: {args.year}')
    

def main(params: argparse.Namespace, args: List[str]) -> None:
    year = params.year
    if not year:
        year = CALYEAR
    interactive = None
    if params.interactive:
        interactive = True
    if params.no_interactive:
        interactive = False
    if interactive is None:
        interactive = not args
    
    votes_manager = TrackerManager(
        votes_file=params.votes_file,
        groupings_file=params.groupings_file,
        results_file=params.results_file,
        year=year,
        interactive=interactive
    )
    if interactive:
        votes_manager.cmdloop(TrackerManager.combobulate_line(args))
    else:
        votes_manager.onecmd(TrackerManager.combobulate_line(args))


if __name__ == '__main__':
    parser = cmd2.Cmd2ArgumentParser("votes", description="manage votes")
    parser.add_argument(
        '--year', '-Y',
        default='',
        help=f'Specify a year. Defaults to the current calendar year. CURRENTLY: {CALYEAR}'
    )
    parser.add_argument(
        '--votes-file', '-V',
        default='votes.json',
        help='file to load and save voting data'
    )
    parser.add_argument(
        '--groupings-file', '-G',
        default='groupings.json',
        help='file to lad and save groupings'
    )
    parser.add_argument(
        '--results-file', '-R',
        default='results.json',
        help='file to load and save results'
    )
    parser.add_argument(
        '--interactive', '-i',
        action='store_true',
        help='Force interactive mode'
    )
    parser.add_argument(
        '--no-interactive', '-I',
        action='store_true',
        help='Force disable interactive mode'
    )

    params = parser.parse_known_args()
    args = list()
    if isinstance(params, tuple):
        params, args = params
    main(params, args)
